<!DOCTYPE html><html><head><meta charset="utf-8"><title>hints_voor_samenwerking</title><style></style></head><body id="preview">
<h1 class="code-line" data-line-start="0" data-line-end="1"><a id="Een_paar_hints_voor_samenwerking_op_grotere_projecten_0"></a>Een paar hints voor samenwerking op grotere projecten</h1>
<h2 class="code-line" data-line-start="5" data-line-end="6"><a id="1_WAT_ga_je_maken_5"></a>1. WAT ga je maken?</h2>
<p class="has-line-data" data-line-start="7" data-line-end="8">Wie is de klant of gebruiker? Wat wil die persoon bereiken met de software?</p>
<p class="has-line-data" data-line-start="9" data-line-end="10">Het kan helpen een typische ‘hoofdklant’ (een zogeheten ‘persona’) te kiezen of te verzinnen,bijvoorbeeld Piet Jansen, 32 jaar, hypotheekadviseur bij de ING, wil kunnen zien welk hypotheekpakket het voordeligst is voor zijn cliënt.</p>
<p class="has-line-data" data-line-start="11" data-line-end="12">Daarnaast is het handig een paar logische stappen te bedenken waarmee die persoon zijn of haar doelen kan bereiken. Bijvoorbeeld: invoeren koopprijs huis, eigen kapitaal cliënt, inkomen cliënt en eventuele partner… dan op een knop drukken en een lijstje met alternatieven zien qua looptijd en totale kosten exclusief hypotheekrenteaftrek.</p>
<h2 class="code-line" data-line-start="14" data-line-end="15"><a id="2_HOE_ga_je_het_maken_14"></a>2. HOE ga je het maken?</h2>
<p class="has-line-data" data-line-start="15" data-line-end="16">Als je weet wat je wilt maken, ga je kijken wat daar het beste voor is:</p>
<ul>
<li class="has-line-data" data-line-start="16" data-line-end="17">een webapplicatie?</li>
<li class="has-line-data" data-line-start="17" data-line-end="18">een mobiele applicatie?</li>
<li class="has-line-data" data-line-start="18" data-line-end="19">een desktopapplicatie?</li>
<li class="has-line-data" data-line-start="19" data-line-end="21">een programma dat ergens op een supercomputer draait?</li>
</ul>
<p class="has-line-data" data-line-start="21" data-line-end="22">Het is ook belangrijk om erachter te komen of er speciale vereisten aan de software worden gesteld. Voor applicaties waar snelheid en timing cruciaal zijn gebruik je geen garbage-collected taal als Java of C#. Weinig geheugen? Denk aan C. Zijn er voor de taal die je overweegt nuttige bibliotheken? (toen een team waarin ik bij een vorige baan werkte een applicatie wilde maken die SOAP gebruikte werden we erg gehinderd omdat er toendertijd nog geen SOAP-bibliotheken voor .NET Core 3.1 waren; maar die waren er wel voor C++ of Java)</p>
<p class="has-line-data" data-line-start="23" data-line-end="24">Als er meerdere technische alternatieven zijn kun je kijken naar hoe populair ze zijn (meer antwoorden op Stack Overflow), hoe rijp ze zijn (vol kinderziektes of juist aan vervanging toe), en of er andere relevante factoren zijn (kosten, geheugengebruik, snelheid, of de klant mensen heeft die al met die technologie (kunnen) werken).</p>
<p class="has-line-data" data-line-start="25" data-line-end="26">Kiezen voor de programmeertaal die je al kent is overigens niet altijd verstandig; zo heb ik eens een team meegemaakt dat voor Xamarin koos voor mobile app development omdat ze al C# kenden; maar het probleem van mobile app development is niet de programmeertaal, maar het kennen en beheersen van de bibliotheken! Aangezien het 4 jaar duurde voordat ze hun eerste versie af hebben denk ik dat het waarschijnlijk beter was geweest als ze een populairder of beter gesupport framework hadden gebruikt, zoals React Native of Flutter of desnoods Swift.</p>
<p class="has-line-data" data-line-start="27" data-line-end="28">Zulke belangrijke beslissingen noteer je normaal als team ergens in je git repo, dat noem je dan Architectural Decision Records (of Lightweight Architectural Decision Records); op internet kun je daar meer over vinden.</p>
<h2 class="code-line" data-line-start="29" data-line-end="30"><a id="3_Begin_met_het_uitvoeren_van_de_plannen_29"></a>3. Begin met het uitvoeren van de plannen</h2>
<p class="has-line-data" data-line-start="31" data-line-end="32">Als je weet <em>wat</em> je wilt gaan doen en <em>hoe</em> je het wilt gaan doen, is de volgende stap iets werkends te krijgen. Omdat er een grote variëteit is aan problemen die met software kan worden opgelost zijn er ook verschillende methodes, maar de meest succesvolle methodes zijn evolutionair: je begint met iets kleins en past dat aan op basis van feedback van de klant. Want hoe belangrijk het ook is te plannen, vaak weet een klant niet precies wat hij wil voordat hij het uitprobeert, en ook als programmeur begrijp je een probleem aan het begin zelden volledig.</p>
<p class="has-line-data" data-line-start="33" data-line-end="34">Ideaal maak je dus een klein prototype dat een beetje doet van de gewenste functionaliteit. Maar wat een goed prototype is, hangt af van de omstandigheden.</p>
<ul>
<li class="has-line-data" data-line-start="35" data-line-end="36">als je de technologiestack goed beheerst maar er onzekerheden zijn over de functionaliteit en welke data precies relevant is voor de gebruiker: werk eerst met heel simpele prototypes van de front-end, die eventueel nep-data teruggeven.</li>
<li class="has-line-data" data-line-start="36" data-line-end="38">als er onzekerheden zijn over de techniek kan het goed zijn een ‘tracer-bullet-aanpak’ te gebruiken (zie ‘The Pragmatic Programmer’ van David Thomas en Andy Hunt): je maakt 1 feature, van frontend naar backend en terug. Je vraagt bijvoorbeeld record 1 aan de database.</li>
</ul>
<p class="has-line-data" data-line-start="38" data-line-end="39">Meestal zou ik zelf aanbevelen één feature te kiezen die relatief simpel is maar ook waarde heeft voor de gebruiker en die als ‘tracer bullet’ in te zetten, dan heb je een template waar andere features ook aan kunnen worden toegevoegd.</p>
<p class="has-line-data" data-line-start="40" data-line-end="41">Zodra je een beeld hebt van wat er allemaal gedaan moet worden, maak je een aantal taken aan, zet die op het scrum-board, en verfijn je de taken (schrijf je toelichting) tot het iedereen duidelijk is wat er moet gebeuren.</p>
<h2 class="code-line" data-line-start="42" data-line-end="43"><a id="4_De_taakverdeling_42"></a>4. De taakverdeling</h2>
<p class="has-line-data" data-line-start="44" data-line-end="45">Wel is er soms de vraag hoe je de taken opsplitst.</p>
<p class="has-line-data" data-line-start="46" data-line-end="47">Zeker de eerste uren is het lastig om parallel te werken: er zijn dan nog weinig files, dus je krijgt overal merge-conflicten als je parallel werkt. Beter is het dat de eerste uren een paar groepsgenoten met pair programming de basale structuur en de eerste files van het project opzetten, terwijl andere teamgenoten onderzoek doen naar bijvoorbeeld de vereisten of een database of alvast een eerste versie van het scrumboard maakt op basis van de beschrijving. Ga de eerste uren/dag in elk geval niet apart coderen in dezelfde files! Na een paar uur of een dag ofzo heb je echter vaak wel genoeg om taken uit te gaan splitsen.</p>
<p class="has-line-data" data-line-start="48" data-line-end="49">In onze ervaring beginnen veel mensen taken ‘horizontaal’ op te delen: jij doet de database, jij doet de front-end, jij doet de back-end. Dat <em>kan</em> werken, maar heeft een aantal nadelen:</p>
<ol>
<li class="has-line-data" data-line-start="49" data-line-end="50">vaak is er in een periode bijzonder veel of bijzonder weinig werk aan de front-end, waardoor degene die de frontend doet of niets te doen heeft, of de anderen moeten wachten tot de frontend af is.</li>
<li class="has-line-data" data-line-start="50" data-line-end="52">er is meer communicatie nodig en zorgt voor onderbrekingen van de werkflow: vaak heeft de frontend bijvoorbeeld een bepaald endpoint nodig, maar is dat (nog) niet in de backend. Dan moet de frontend of een andere taak oppakken tot de backend af is (wat niet erg efficiënt is), of de backender lastig vallen om van taak te wisselen en onmiddellijk de nieuwe taak te doen, en dan ook nog precies aangeven hoe dat moet.</li>
</ol>
<p class="has-line-data" data-line-start="52" data-line-end="53">Het is vaak dus handiger de taken te verdelen in kleine features, waarbij zowel het front-end, backend als database-deel in dezelfde taak zitten en door dezelfde persoon worden uitgevoerd.</p>
<p class="has-line-data" data-line-start="54" data-line-end="55">“Vertikaal” denken is ook om een andere reden handig: een klant heeft er veel meer aan (en kan betere feedback geven) als er een paar features zijn die werken dan als er een heleboel features zijn die niet werken (omdat de backend er nog niet is) of niet zichtbaar zijn (omdat de frontend er nog niet is). En pas door feedback of zelf met features experimenteren kom je erachter of er iets aan het ontwerp aangepast moet worden, wat je normaal zo vroeg mogelijk in het programmeerproces wilt weten omdat je dan minder code hoeft aan te passen om het te veranderen.</p>
<p class="has-line-data" data-line-start="56" data-line-end="57">Als je Scrum gebruikt doorloopt een taak verschillende stappen:</p>
<ul>
<li class="has-line-data" data-line-start="57" data-line-end="58">TODO: moet nog worden opgepakt deze sprint</li>
<li class="has-line-data" data-line-start="58" data-line-end="59">IN PROGRESS: iemand (een developer) is ermee bezig</li>
<li class="has-line-data" data-line-start="59" data-line-end="60">READY FOR REVIEW: er is een pull request gemaakt die moet worden opgepikt door een (of twee) reviewer(s)</li>
<li class="has-line-data" data-line-start="60" data-line-end="62">UNDER REVIEW: als de taak gereviewd wordt<br>
na de UNDER REVIEW kan de taak eventueel, als er veranderingen worden gevraagd, worden teruggezet naar IN PROGRESS terwijl de reviewcommentaren worden verwerkt, en daarna weer in READY FOR REVIEW worden gezet.</li>
<li class="has-line-data" data-line-start="62" data-line-end="64">DONE: de taak is in development ingemerged.</li>
</ul>
<h2 class="code-line" data-line-start="64" data-line-end="65"><a id="5_De_branching_en_taken_64"></a>5. De branching en taken</h2>
<p class="has-line-data" data-line-start="66" data-line-end="67">Er zijn heel veel branching-structuren mogelijk. In een echt bedrijf heb je soms OTAP-branches (Ontwikkeling, Test, Acceptatie, Productie), of een main branch waar alle officiële releases op komen en een development-branch voor het dagelijks werk van de developers.</p>
<p class="has-line-data" data-line-start="68" data-line-end="70">Maar voor kleinere projecten als deze is een development-branch voldoende;<br>
Als je een taak oppakt maak je een feature-branch op basis van de huidige development-branch, en geef je het een naam als task_23_add_address_table_to_database</p>
<p class="has-line-data" data-line-start="71" data-line-end="72">Omdat programmeurs mensen zijn en daarom makkelijk foutjes maken worden normaal ook ‘branching policies’ ingesteld: dat je bijvoorbeeld nooit rechtstreeks naar development kan mergen, maar dat dat altijd via een pull request moet gebeuren die door minstens één ander persoon moet worden goedgekeurd.</p>
<p class="has-line-data" data-line-start="73" data-line-end="74">Als je klaar bent met de taak, test je het als developer, merge je de huidige development-branch erin, test je het weer voor de zekerheid, en zet je het op ready for review.</p>
<p class="has-line-data" data-line-start="75" data-line-end="76">Nu is het in onze ervaring voor beginnende reviewers soms verleidelijk de code door te scannen en dan te approven, want ‘het project moet af’. Maar in de beroepspraktijk is een project nooit ‘af’, en haastige spoed is nooit goed omdat fouten die je in een review over het hoofd ziet later veel ellende kunnen veroorzaken. Bovendien ben je hier om te leren professionele code te produceren: we zullen ons nooit zorgen maken over dat je iets niet af krijgt (zo nauwkeurig kunnen we opgaven ook niet plannen), maar wel als je slechte, moeilijk onderhoudbare code aflevert. Wat er in je project zit, moet werken, en staan als een huis, met professioneel ogende code. Met een project met de helft van de features die wèl allemaal werken en goed onderhoudbare code bevatten kan je veel makkelijker een stage of baan vinden dan met een ‘afgemaakt’ project waar een klant overal bugs tegenkomt, die overigens niet kunnen worden opgelost door de spaghetticode die zich overal bevindt.</p>
<p class="has-line-data" data-line-start="77" data-line-end="78">Zoals Steve McConnell aangeeft in “Code Complete”: hoe eerder je een fout vindt, des te sneller en dus goedkoper hij is op te lossen. Als een fout pas ontdekt wordt door een gebruiker, weken of maanden na de code review, is het vaak volkomen onduidelijk waar de fout aan ligt en kan het uren of dagen ‘in code graven’ worden. Als je diezelfde fout vindt een in code review van 15 minuten, is dat een zeer goede investering. Om echt snel te programmeren, programmeer en review rustig en zorgvuldig!</p>
<p class="has-line-data" data-line-start="79" data-line-end="80">Dus dat betekent ook dat de reviewer idealter de code naar zijn/haar machine pullt, runt en uittest.</p>
<p class="has-line-data" data-line-start="81" data-line-end="82">Na de review (en goedkeuring) kan je het pull-request meestal afmaken, tenzij er merge-conflicten zijn met een nieuwe versie van de development-branch, dan moet je het proces van development branch lokaal in je feature-branch mergen en review aanvragen herhalen. Gelukkig komt dat niet vaak voor.</p>
<p class="has-line-data" data-line-start="83" data-line-end="84">En als die taak af is kun je een andere taak van het board opnemen!</p>
<p class="has-line-data" data-line-start="85" data-line-end="86"><strong>Belangrijk</strong>: probeer het zo met je team te regelen dat taken klein zijn: een paar uur tot een dag. Als je een grote taak hebt die een paar dagen tot een week duurt, zorgt dat vaak voor extra problemen omdat:</p>
<ul>
<li class="has-line-data" data-line-start="86" data-line-end="87">de kans groter is op merge-conflicten</li>
<li class="has-line-data" data-line-start="87" data-line-end="88">de kans groter is dat het niet goed samenwerkt met andere code en je dus meer wijzigingen moet doen om de branch werkend te krijgen</li>
<li class="has-line-data" data-line-start="88" data-line-end="90">weinig mensen een pull-request van tientallen files willen reviewen; het duurt langer en gebeurt meestal ook minder zorgvuldig.</li>
</ul>
<p class="has-line-data" data-line-start="90" data-line-end="91">Er zijn dus teams die minstens 1x per dag het werk van iedereen samenmergen, zelfs al is een feature nog niet helemaal af; maar dat vereist normaal ervaren programmeurs, snelle en goede reviews, veel unittests en extra code om te voorkomen dat half-afgemaakte features zichtbaar zijn. Dus meestal is het gewoon beter de taken en pull requests klein te houden!</p>
<p class="has-line-data" data-line-start="92" data-line-end="93">Overigens: programmeren en reviewen zijn niet de enige mogelijke taken: iets uitzoeken is ook een taak, normaal timebox je dat (zeg 1 uur, of 2 uur, of een halve dag), dat heet dan een ‘spike’.</p>
<h2 class="code-line" data-line-start="94" data-line-end="95"><a id="6_YAGNI_en_KISS_94"></a>6. YAGNI en KISS</h2>
<p class="has-line-data" data-line-start="95" data-line-end="98">Developers zijn vaak creatieve mensen die goed zijn in het zien van mogelijke nieuwe eisen, die kunnen worden opgelost door een extra parameter aan een methode toe te voegen, een extra klasse te maken, een extra interface te bedenken… Normaal is dat echter niet verstandig, want ons zicht op het probleem is vaak nogal beperkt; de klant/gebruiker weet het wel, maar die ziet het pas beter als hij/zij de software ook daadwerkelijk gebruikt. Als je bezig bent extra code te schrijven voor een feature die (nog) niet gevraagd wordt, is er een heel grote kans (90% ofzo) dat je zo meer code moet weghalen of veranderen omdat er heel iets anders wordt gevraagd, of dat je ‘alleen maar’ meer overbodige code moet lezen bij codereviews of het zoeken naar code die je moet veranderen (<em>‘code is not an asset, it’s a liability’</em>); en krijgt de klant/gebruiker de features die hij/zij WEL wil juist later… Mogelijk is YAGNI niet het meest technische aspect van software-ontwikkeling, maar het kan wel een emotioneel probleem zijn dat je project kan vertragen. Probeer dus je YAGNI-neigingen te herkennen en eventueel in bedwang te houden. Meer lezen?<br>
<a href="https://enterprisecraftsmanship.com/posts/yagni-revisited/">https://enterprisecraftsmanship.com/posts/yagni-revisited/</a><br>
<a href="https://martinfowler.com/bliki/Yagni.html">https://martinfowler.com/bliki/Yagni.html</a></p>
<h2 class="code-line" data-line-start="99" data-line-end="100"><a id="7_Documentatie_99"></a>7. Documentatie</h2>
<p class="has-line-data" data-line-start="100" data-line-end="101">het is handig documentatie bij te houden, ook naast de Architectural Decision Records, bijvoorbeeld:</p>
<ul>
<li class="has-line-data" data-line-start="101" data-line-end="102">Entity Relationship Diagrams: een overzicht van de database</li>
<li class="has-line-data" data-line-start="102" data-line-end="103">soms: verslag van overleg met gebruikers/klanten</li>
<li class="has-line-data" data-line-start="103" data-line-end="104">soms: wireframes/ontwerpen van de GUI</li>
<li class="has-line-data" data-line-start="104" data-line-end="105">als je een API hebt: API-documentatie met documentation comments</li>
<li class="has-line-data" data-line-start="105" data-line-end="106">soms: (zeker als je Domain Driven Design gebruikt, een aanrader) een woordenlijst met termen die je in het project gebruikt. Noem je iemand die een cursus volgt een Trainee, een Coachee, een Student, of een Customer? Als het hele team dezelfde term gebruikt, is het zoeken naar de juiste klassen en methodes een stuk makkelijker. Zoek maar eens op internet naar “ubiquitous language” / Domain Driven Design.</li>
<li class="has-line-data" data-line-start="106" data-line-end="107">soms: schetsen van klassendiagrammen met begeleidende tekst om de relaties tussen de verschillende klassen duidelijk te maken.</li>
</ul>
<h2 class="code-line" data-line-start="109" data-line-end="110"><a id="8_Overige_tips_109"></a>8. Overige tips:</h2>
<ul>
<li class="has-line-data" data-line-start="110" data-line-end="112">bij scrum: als je met Sprints werkt, is het handig het algemene backlog gescheiden te houden van de sprint backlog, dan kan je aan het einde van de sprint makkelijk zien voor de sprintreview welke taken deze sprint zijn afgerond.</li>
</ul>
<h3 class="code-line" data-line-start="112" data-line-end="113"><a id="Changelog_112"></a>Changelog</h3>
<ul>
<li class="has-line-data" data-line-start="113" data-line-end="114">20230404: branching policies vermeld, het belang van goed reviewen (en dat de reviewer ook de code uittest) toegevoegd.</li>
</ul>
</body></html>